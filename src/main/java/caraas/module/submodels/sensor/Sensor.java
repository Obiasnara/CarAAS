/*******************************************************************************
 * Copyright (c) 2024 DFKI.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     DFKI - Tapanta Bhanja <tapanta.bhanja@dfki.de>
 *******************************************************************************/ 
package caraas.module.submodels.sensor;

import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.List;

import java.math.BigInteger; 

import javax.xml.datatype.XMLGregorianCalendar;
import javax.xml.datatype.Duration;
import javax.xml.namespace.QName;

import caraas.connection.ConnectedDevices;
//import caraas.connection.DataCrawler;
import caraas.module.AASServer;
import caraas.module.ConceptDescriptions;
import caraas.connection.OpcUaVariable;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.operation.Operation;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.SubmodelElementCollection;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.dataelement.property.valuetype.ValueType;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.dataelement.File;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.dataelement.property.Property;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.dataelement.MultiLanguageProperty;
import org.eclipse.basyx.submodel.metamodel.map.qualifier.LangStrings;
import org.eclipse.basyx.submodel.metamodel.map.reference.Key; 
import org.eclipse.basyx.submodel.metamodel.map.reference.Reference; 
import org.eclipse.basyx.submodel.metamodel.api.reference.IKey;
import org.eclipse.basyx.submodel.metamodel.api.reference.enums.KeyElements; 
import org.eclipse.basyx.submodel.metamodel.api.reference.enums.KeyType; 
import org.eclipse.basyx.submodel.metamodel.api.identifier.IdentifierType;
import org.eclipse.basyx.submodel.metamodel.api.qualifier.haskind.ModelingKind;
import org.eclipse.basyx.submodel.metamodel.api.submodelelement.ISubmodelElement;
import org.eclipse.basyx.submodel.metamodel.map.Submodel;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.operation.OperationVariable;
import com.festo.aas.p4m.connection.ValueDelegate; 
import org.eclipse.basyx.vab.protocol.opcua.types.NodeId;
import org.eclipse.basyx.vab.protocol.opcua.types.UnsignedShort;
import com.festo.aas.p4m.connection.ConnectedProperty;

/**
 * 
 * @author DFKI
 * 
 * Do not edit this file for changing operation behaviours. 
 */

public class Sensor extends Submodel {

	/**
	 * This field variable holds all configured connectors to the asset. 
	 * Use these connectors to communicate with your asset.
	 */
	private ConnectedDevices connectedDevices;

	private ConceptDescriptions conceptDescriptions;

	/**
     * This class contains all user-provided code for operations.
     */
	private final DynamicElementsWorkspace dew; 

	 /**
     * This class contains all user-provided code for value delegates.
     */

	 /**
     * The following contains the declaration of the operation variables as field variables so that they can be accessed in their true sense.
     */


	public Sensor() {

		try {
			connectedDevices = new ConnectedDevices();
		} 
		catch (Exception e) {

			e.printStackTrace();
		}
		
		dew = new DynamicElementsWorkspace(connectedDevices);
		conceptDescriptions = new ConceptDescriptions();

		setIdShort("Sensor");
		setIdentification(IdentifierType.IRI, AASServer.getSettings().SUBMODEL_SENSOR_IRI.get().toString()); 
		setKind(ModelingKind.TEMPLATE); 
		List<IKey> sensorKeys= new ArrayList<IKey>();
		Reference SensorRef = new Reference(sensorKeys);
		setSemanticId(SensorRef); 
 
		SubmodelElementCollection Sensor_Battery_Sensor = new SubmodelElementCollection();
		Collection<ISubmodelElement> Sensor_Battery_Sensorvalue = new ArrayList<ISubmodelElement>();
		Sensor_Battery_Sensor.setIdShort("Battery_Sensor");
		Sensor_Battery_Sensor.setAllowDuplicates(false);
		Sensor_Battery_Sensor.setOrdered(false);
     	Sensor_Battery_Sensor.setKind(ModelingKind.TEMPLATE);
		addSubmodelElement(Sensor_Battery_Sensor);
		List<IKey> Sensor_battery_sensorKeys= new ArrayList<IKey>();
		Reference Sensor_Battery_SensorRef = new Reference(Sensor_battery_sensorKeys);
		Sensor_Battery_Sensor.setSemanticId(Sensor_Battery_SensorRef); 
 


		Property Battery_Sensor_isLocatedAt= new Property();
		Battery_Sensor_isLocatedAt.setIdShort("isLocatedAt");
		Battery_Sensor_isLocatedAt.setValueType(ValueType.String);
		List<IKey> Battery_Sensor_islocatedatKeys= new ArrayList<IKey>();
		Reference Battery_Sensor_isLocatedAtRef = new Reference(Battery_Sensor_islocatedatKeys);
		Battery_Sensor_isLocatedAt.setSemanticId(Battery_Sensor_isLocatedAtRef); 
 
		Battery_Sensor_isLocatedAt.setKind(ModelingKind.TEMPLATE);
		Sensor_Battery_Sensorvalue.add(Battery_Sensor_isLocatedAt);

		Battery_Sensor_isLocatedAt.setValue("null");


		// Adding the SubmodelElements that belong to SubmodelElementCollection - Battery_Sensor. 
		Sensor_Battery_Sensor.setElements(Sensor_Battery_Sensorvalue.stream().collect(Collectors.toMap(ISubmodelElement::getIdShort, Function.identity())));
 
		SubmodelElementCollection Sensor_Camera_Sensor = new SubmodelElementCollection();
		Collection<ISubmodelElement> Sensor_Camera_Sensorvalue = new ArrayList<ISubmodelElement>();
		Sensor_Camera_Sensor.setIdShort("Camera_Sensor");
		Sensor_Camera_Sensor.setAllowDuplicates(false);
		Sensor_Camera_Sensor.setOrdered(false);
     	Sensor_Camera_Sensor.setKind(ModelingKind.TEMPLATE);
		addSubmodelElement(Sensor_Camera_Sensor);
		List<IKey> Sensor_camera_sensorKeys= new ArrayList<IKey>();
		Reference Sensor_Camera_SensorRef = new Reference(Sensor_camera_sensorKeys);
		Sensor_Camera_Sensor.setSemanticId(Sensor_Camera_SensorRef); 
 


		Property Camera_Sensor_isLocatedAt= new Property();
		Camera_Sensor_isLocatedAt.setIdShort("isLocatedAt");
		Camera_Sensor_isLocatedAt.setValueType(ValueType.String);
		List<IKey> Camera_Sensor_islocatedatKeys= new ArrayList<IKey>();
		Reference Camera_Sensor_isLocatedAtRef = new Reference(Camera_Sensor_islocatedatKeys);
		Camera_Sensor_isLocatedAt.setSemanticId(Camera_Sensor_isLocatedAtRef); 
 
		Camera_Sensor_isLocatedAt.setKind(ModelingKind.TEMPLATE);
		Sensor_Camera_Sensorvalue.add(Camera_Sensor_isLocatedAt);

		Camera_Sensor_isLocatedAt.setValue("null");


		// Adding the SubmodelElements that belong to SubmodelElementCollection - Camera_Sensor. 
		Sensor_Camera_Sensor.setElements(Sensor_Camera_Sensorvalue.stream().collect(Collectors.toMap(ISubmodelElement::getIdShort, Function.identity())));
 
		SubmodelElementCollection Sensor_Engine_Sensor = new SubmodelElementCollection();
		Collection<ISubmodelElement> Sensor_Engine_Sensorvalue = new ArrayList<ISubmodelElement>();
		Sensor_Engine_Sensor.setIdShort("Engine_Sensor");
		Sensor_Engine_Sensor.setAllowDuplicates(false);
		Sensor_Engine_Sensor.setOrdered(false);
     	Sensor_Engine_Sensor.setKind(ModelingKind.TEMPLATE);
		addSubmodelElement(Sensor_Engine_Sensor);
		List<IKey> Sensor_engine_sensorKeys= new ArrayList<IKey>();
		Reference Sensor_Engine_SensorRef = new Reference(Sensor_engine_sensorKeys);
		Sensor_Engine_Sensor.setSemanticId(Sensor_Engine_SensorRef); 
 


		Property Engine_Sensor_isLocatedAt= new Property();
		Engine_Sensor_isLocatedAt.setIdShort("isLocatedAt");
		Engine_Sensor_isLocatedAt.setValueType(ValueType.String);
		List<IKey> Engine_Sensor_islocatedatKeys= new ArrayList<IKey>();
		Reference Engine_Sensor_isLocatedAtRef = new Reference(Engine_Sensor_islocatedatKeys);
		Engine_Sensor_isLocatedAt.setSemanticId(Engine_Sensor_isLocatedAtRef); 
 
		Engine_Sensor_isLocatedAt.setKind(ModelingKind.TEMPLATE);
		Sensor_Engine_Sensorvalue.add(Engine_Sensor_isLocatedAt);

		Engine_Sensor_isLocatedAt.setValue("null");


		// Adding the SubmodelElements that belong to SubmodelElementCollection - Engine_Sensor. 
		Sensor_Engine_Sensor.setElements(Sensor_Engine_Sensorvalue.stream().collect(Collectors.toMap(ISubmodelElement::getIdShort, Function.identity())));
 
		SubmodelElementCollection Sensor_Ultrasonic_Sensor = new SubmodelElementCollection();
		Collection<ISubmodelElement> Sensor_Ultrasonic_Sensorvalue = new ArrayList<ISubmodelElement>();
		Sensor_Ultrasonic_Sensor.setIdShort("Ultrasonic_Sensor");
		Sensor_Ultrasonic_Sensor.setAllowDuplicates(false);
		Sensor_Ultrasonic_Sensor.setOrdered(false);
     	Sensor_Ultrasonic_Sensor.setKind(ModelingKind.TEMPLATE);
		addSubmodelElement(Sensor_Ultrasonic_Sensor);
		List<IKey> Sensor_ultrasonic_sensorKeys= new ArrayList<IKey>();
		Reference Sensor_Ultrasonic_SensorRef = new Reference(Sensor_ultrasonic_sensorKeys);
		Sensor_Ultrasonic_Sensor.setSemanticId(Sensor_Ultrasonic_SensorRef); 
 


		Property Ultrasonic_Sensor_isLocatedAt= new Property();
		Ultrasonic_Sensor_isLocatedAt.setIdShort("isLocatedAt");
		Ultrasonic_Sensor_isLocatedAt.setValueType(ValueType.String);
		List<IKey> Ultrasonic_Sensor_islocatedatKeys= new ArrayList<IKey>();
		Reference Ultrasonic_Sensor_isLocatedAtRef = new Reference(Ultrasonic_Sensor_islocatedatKeys);
		Ultrasonic_Sensor_isLocatedAt.setSemanticId(Ultrasonic_Sensor_isLocatedAtRef); 
 
		Ultrasonic_Sensor_isLocatedAt.setKind(ModelingKind.TEMPLATE);
		Sensor_Ultrasonic_Sensorvalue.add(Ultrasonic_Sensor_isLocatedAt);

		Ultrasonic_Sensor_isLocatedAt.setValue("null");


		// Adding the SubmodelElements that belong to SubmodelElementCollection - Ultrasonic_Sensor. 
		Sensor_Ultrasonic_Sensor.setElements(Sensor_Ultrasonic_Sensorvalue.stream().collect(Collectors.toMap(ISubmodelElement::getIdShort, Function.identity())));
 
	}
	
}


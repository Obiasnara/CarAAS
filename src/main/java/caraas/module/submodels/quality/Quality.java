/*******************************************************************************
 * Copyright (c) 2024 DFKI.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     DFKI - Tapanta Bhanja <tapanta.bhanja@dfki.de>
 *******************************************************************************/ 
package caraas.module.submodels.quality;

import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.List;

import java.math.BigInteger; 

import javax.xml.datatype.XMLGregorianCalendar;
import javax.xml.datatype.Duration;
import javax.xml.namespace.QName;

import caraas.connection.ConnectedDevices;
//import caraas.connection.DataCrawler;
import caraas.module.AASServer;
import caraas.module.ConceptDescriptions;
import caraas.connection.OpcUaVariable;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.operation.Operation;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.SubmodelElementCollection;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.dataelement.property.valuetype.ValueType;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.dataelement.File;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.dataelement.property.Property;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.dataelement.MultiLanguageProperty;
import org.eclipse.basyx.submodel.metamodel.map.qualifier.LangStrings;
import org.eclipse.basyx.submodel.metamodel.map.reference.Key; 
import org.eclipse.basyx.submodel.metamodel.map.reference.Reference; 
import org.eclipse.basyx.submodel.metamodel.api.reference.IKey;
import org.eclipse.basyx.submodel.metamodel.api.reference.enums.KeyElements; 
import org.eclipse.basyx.submodel.metamodel.api.reference.enums.KeyType; 
import org.eclipse.basyx.submodel.metamodel.api.identifier.IdentifierType;
import org.eclipse.basyx.submodel.metamodel.api.qualifier.haskind.ModelingKind;
import org.eclipse.basyx.submodel.metamodel.api.submodelelement.ISubmodelElement;
import org.eclipse.basyx.submodel.metamodel.map.Submodel;
import org.eclipse.basyx.submodel.metamodel.map.submodelelement.operation.OperationVariable;
import com.festo.aas.p4m.connection.ValueDelegate; 
import org.eclipse.basyx.vab.protocol.opcua.types.NodeId;
import org.eclipse.basyx.vab.protocol.opcua.types.UnsignedShort;
import com.festo.aas.p4m.connection.ConnectedProperty;

/**
 * 
 * @author DFKI
 * 
 * Do not edit this file for changing operation behaviours. 
 */

public class Quality extends Submodel {

	/**
	 * This field variable holds all configured connectors to the asset. 
	 * Use these connectors to communicate with your asset.
	 */
	private ConnectedDevices connectedDevices;

	private ConceptDescriptions conceptDescriptions;

	/**
     * This class contains all user-provided code for operations.
     */
	private final DynamicElementsWorkspace dew; 

	 /**
     * This class contains all user-provided code for value delegates.
     */

	 /**
     * The following contains the declaration of the operation variables as field variables so that they can be accessed in their true sense.
     */


	public Quality() {

		try {
			connectedDevices = new ConnectedDevices();
		} 
		catch (Exception e) {

			e.printStackTrace();
		}
		
		dew = new DynamicElementsWorkspace(connectedDevices);
		conceptDescriptions = new ConceptDescriptions();

		setIdShort("Quality");
		setIdentification(IdentifierType.IRI, AASServer.getSettings().SUBMODEL_QUALITY_IRI.get().toString()); 
		setKind(ModelingKind.TEMPLATE); 
		List<IKey> qualityKeys= new ArrayList<IKey>();
		Reference QualityRef = new Reference(qualityKeys);
		setSemanticId(QualityRef); 
 
		SubmodelElementCollection Quality_Battery_Level = new SubmodelElementCollection();
		Collection<ISubmodelElement> Quality_Battery_Levelvalue = new ArrayList<ISubmodelElement>();
		Quality_Battery_Level.setIdShort("Battery_Level");
		Quality_Battery_Level.setAllowDuplicates(false);
		Quality_Battery_Level.setOrdered(false);
     	Quality_Battery_Level.setKind(ModelingKind.TEMPLATE);
		addSubmodelElement(Quality_Battery_Level);
		List<IKey> Quality_battery_levelKeys= new ArrayList<IKey>();
		Reference Quality_Battery_LevelRef = new Reference(Quality_battery_levelKeys);
		Quality_Battery_Level.setSemanticId(Quality_Battery_LevelRef); 
 


		Property Battery_Level_hasTreshold= new Property();
		Battery_Level_hasTreshold.setIdShort("hasTreshold");
		Battery_Level_hasTreshold.setValueType(ValueType.Float);
		List<IKey> Battery_Level_hastresholdKeys= new ArrayList<IKey>();
		Reference Battery_Level_hasTresholdRef = new Reference(Battery_Level_hastresholdKeys);
		Battery_Level_hasTreshold.setSemanticId(Battery_Level_hasTresholdRef); 
 
		Battery_Level_hasTreshold.setKind(ModelingKind.TEMPLATE);
		Quality_Battery_Levelvalue.add(Battery_Level_hasTreshold);

		Battery_Level_hasTreshold.setValue("null");


		// Adding the SubmodelElements that belong to SubmodelElementCollection - Battery_Level. 
		Quality_Battery_Level.setElements(Quality_Battery_Levelvalue.stream().collect(Collectors.toMap(ISubmodelElement::getIdShort, Function.identity())));
 
		SubmodelElementCollection Quality_Distance_To_Object = new SubmodelElementCollection();
		Collection<ISubmodelElement> Quality_Distance_To_Objectvalue = new ArrayList<ISubmodelElement>();
		Quality_Distance_To_Object.setIdShort("Distance_To_Object");
		Quality_Distance_To_Object.setAllowDuplicates(false);
		Quality_Distance_To_Object.setOrdered(false);
     	Quality_Distance_To_Object.setKind(ModelingKind.TEMPLATE);
		addSubmodelElement(Quality_Distance_To_Object);
		List<IKey> Quality_distance_to_objectKeys= new ArrayList<IKey>();
		Reference Quality_Distance_To_ObjectRef = new Reference(Quality_distance_to_objectKeys);
		Quality_Distance_To_Object.setSemanticId(Quality_Distance_To_ObjectRef); 
 


		Property Distance_To_Object_hasMinimalDistance= new Property();
		Distance_To_Object_hasMinimalDistance.setIdShort("hasMinimalDistance");
		Distance_To_Object_hasMinimalDistance.setValueType(ValueType.Integer);
		List<IKey> Distance_To_Object_hasminimaldistanceKeys= new ArrayList<IKey>();
		Reference Distance_To_Object_hasMinimalDistanceRef = new Reference(Distance_To_Object_hasminimaldistanceKeys);
		Distance_To_Object_hasMinimalDistance.setSemanticId(Distance_To_Object_hasMinimalDistanceRef); 
 
		Distance_To_Object_hasMinimalDistance.setKind(ModelingKind.TEMPLATE);
		Quality_Distance_To_Objectvalue.add(Distance_To_Object_hasMinimalDistance);

		Distance_To_Object_hasMinimalDistance.setValue("null");


		// Adding the SubmodelElements that belong to SubmodelElementCollection - Distance_To_Object. 
		Quality_Distance_To_Object.setElements(Quality_Distance_To_Objectvalue.stream().collect(Collectors.toMap(ISubmodelElement::getIdShort, Function.identity())));
 
		SubmodelElementCollection Quality_Speed = new SubmodelElementCollection();
		Collection<ISubmodelElement> Quality_Speedvalue = new ArrayList<ISubmodelElement>();
		Quality_Speed.setIdShort("Speed");
		Quality_Speed.setAllowDuplicates(false);
		Quality_Speed.setOrdered(false);
     	Quality_Speed.setKind(ModelingKind.TEMPLATE);
		addSubmodelElement(Quality_Speed);
		List<IKey> Quality_speedKeys= new ArrayList<IKey>();
		Reference Quality_SpeedRef = new Reference(Quality_speedKeys);
		Quality_Speed.setSemanticId(Quality_SpeedRef); 
 


		Property Speed_hasMaximalEngineSpeed= new Property();
		Speed_hasMaximalEngineSpeed.setIdShort("hasMaximalEngineSpeed");
		Speed_hasMaximalEngineSpeed.setValueType(ValueType.Integer);
		List<IKey> Speed_hasmaximalenginespeedKeys= new ArrayList<IKey>();
		Reference Speed_hasMaximalEngineSpeedRef = new Reference(Speed_hasmaximalenginespeedKeys);
		Speed_hasMaximalEngineSpeed.setSemanticId(Speed_hasMaximalEngineSpeedRef); 
 
		Speed_hasMaximalEngineSpeed.setKind(ModelingKind.TEMPLATE);
		Quality_Speedvalue.add(Speed_hasMaximalEngineSpeed);

		Speed_hasMaximalEngineSpeed.setValue("null");


		// Adding the SubmodelElements that belong to SubmodelElementCollection - Speed. 
		Quality_Speed.setElements(Quality_Speedvalue.stream().collect(Collectors.toMap(ISubmodelElement::getIdShort, Function.identity())));
 
		SubmodelElementCollection Quality_Images = new SubmodelElementCollection();
		Collection<ISubmodelElement> Quality_Imagesvalue = new ArrayList<ISubmodelElement>();
		Quality_Images.setIdShort("Images");
		Quality_Images.setAllowDuplicates(false);
		Quality_Images.setOrdered(false);
     	Quality_Images.setKind(ModelingKind.TEMPLATE);
		addSubmodelElement(Quality_Images);
		List<IKey> Quality_imagesKeys= new ArrayList<IKey>();
		Reference Quality_ImagesRef = new Reference(Quality_imagesKeys);
		Quality_Images.setSemanticId(Quality_ImagesRef); 
 


		Property Images_hasImageQualityMimimumForRecognition= new Property();
		Images_hasImageQualityMimimumForRecognition.setIdShort("hasImageQualityMimimumForRecognition");
		Images_hasImageQualityMimimumForRecognition.setValueType(ValueType.String);
		List<IKey> Images_hasimagequalitymimimumforrecognitionKeys= new ArrayList<IKey>();
		Reference Images_hasImageQualityMimimumForRecognitionRef = new Reference(Images_hasimagequalitymimimumforrecognitionKeys);
		Images_hasImageQualityMimimumForRecognition.setSemanticId(Images_hasImageQualityMimimumForRecognitionRef); 
 
		Images_hasImageQualityMimimumForRecognition.setKind(ModelingKind.TEMPLATE);
		Quality_Imagesvalue.add(Images_hasImageQualityMimimumForRecognition);

		Images_hasImageQualityMimimumForRecognition.setValue("null");


		// Adding the SubmodelElements that belong to SubmodelElementCollection - Images. 
		Quality_Images.setElements(Quality_Imagesvalue.stream().collect(Collectors.toMap(ISubmodelElement::getIdShort, Function.identity())));
 
	}
	
}

